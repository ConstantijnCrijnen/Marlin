/**
 * Marlin 3D Printer Firmware
 * Copyright (c) 2021 MarlinFirmware [https://github.com/MarlinFirmware/Marlin]
 *
 * Based on Sprinter and grbl.
 * Copyright (c) 2011 Camiel Gubbels / Erik van der Zalm
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 *
 */

#include "../../inc/MarlinConfig.h"

#if ENABLED(BED_SWELL_DWELL)

#include "../gcode.h"
#include "../../module/motion.h"
#include "../../module/probe.h"
#include "../../feature/bedlevel/bedlevel.h"
#include "../../lcd/dogm/marlinui_DOGM.h"
#include "../../lcd/lcdprint.h"
#include "../../lcd/marlinui.h"

const unsigned char plot_backdrop[] PROGMEM = {
  B00000000,B00000000,B10000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,
  B00000011,B10000001,B11000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,
  B00000000,B10000001,B11000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,
  B00000001,B00000011,B11100000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,
  B00000010,B00000000,B10000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,
  B00000011,B10000000,B10000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,
  B00000000,B00000000,B10000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,
  B01101010,B10101100,B10000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,
  B01001010,B11100100,B10000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,
  B01001010,B10100100,B10000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,
  B01001100,B10100100,B10000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,
  B01101000,B10101100,B10000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,
  B00000000,B00000000,B10000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,
  B00000000,B10001000,B10000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,
  B00000001,B01010100,B10000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,
  B00000000,B10010101,B10000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,
  B00000001,B01010100,B10000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,
  B00000000,B10001000,B10000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,
  B00000000,B00000000,B10000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,
  B00000000,B00000000,B10000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,
  B00000000,B10001000,B10000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,
  B00000001,B00010100,B10000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,
  B00000001,B10010101,B10000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,
  B00000001,B01010100,B10000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,
  B00000000,B10001000,B10000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,
  B00000000,B00000000,B10000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,
  B00000000,B00000000,B10000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,
  B00000001,B01001000,B10000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,
  B00000001,B01010100,B10000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,
  B00000001,B01010101,B10000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,
  B00000001,B11010100,B10000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,
  B00000000,B01001000,B10000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,
  B00000000,B00000000,B10000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,
  B00000000,B00000000,B10000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,
  B00000000,B10001000,B10000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,
  B00000001,B01010100,B10000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,
  B00000000,B01010101,B10000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,
  B00000000,B10010100,B10000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,
  B00000001,B11001000,B10000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,
  B00000000,B00000000,B10000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,
  B00000000,B00000000,B10000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,
  B00000000,B00001000,B10000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,
  B00000000,B00010100,B10000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,
  B00000000,B00010101,B10000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,
  B00000000,B00010100,B10000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,
  B00000000,B00001000,B10000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,
  B00000000,B00000000,B10000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,
  B00000000,B00000000,B10000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00001000,
  B00000000,B00000000,B10000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00001110,
  B00000000,B00000000,B11111111,B11111111,B11111111,B11111111,B11111111,B11111111,B11111111,B11111111,B11111111,B11111111,B11111111,B11111111,B11111111,B11111111,
  B00000000,B00000000,B01000000,B00000100,B00000000,B00100000,B00000001,B00000000,B00001000,B00000000,B01000000,B00000000,B00000000,B00000000,B00000000,B00001110,
  B00000000,B00000000,B00010000,B00000001,B10010000,B00001000,B10000000,B01000100,B00000010,B01000100,B00010111,B00100000,B00011101,B01010111,B00110011,B01101000,
  B00000000,B00000000,B00101000,B00000000,B10101000,B00010001,B01000000,B10101010,B00000110,B10101010,B00110100,B01010000,B00001000,B01110100,B00100100,B00100000,
  B00000000,B00000000,B00101000,B00000001,B00101000,B00011001,B01000000,B01101010,B00000010,B00101010,B00010110,B01010000,B00001001,B01010110,B00100010,B00100000,
  B00000000,B00000000,B00101000,B00000000,B10101000,B00010101,B01000000,B00101010,B00000010,B01001010,B00010001,B01010000,B00001001,B01010100,B00100001,B00100000,
  B00000000,B00000000,B00010000,B00000011,B10010000,B00001000,B10000000,B01000100,B00000010,B11100100,B00010110,B00100000,B00001001,B01010111,B00110110,B01100000,
  B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,
  B11111111,B11111111,B11111111,B11111111,B11111111,B11111111,B11111111,B11111111,B11111111,B11111111,B11111111,B11111111,B11111111,B11111111,B11111111,B11111111,
  B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00000000,B00100000,B00000000,B00000000,B00000000,B00000000,B00000000,
  B11001110,B01101100,B11100110,B01101001,B00100000,B00000000,B00000000,B00000010,B10101000,B00100110,B00100011,B10000000,B00000000,B00000000,B00000000,B10101010,
  B10101000,B10001010,B10001000,B10000010,B10110010,B00000000,B00000000,B00000010,B10111000,B01001000,B00100000,B10100000,B00000000,B00000000,B00000000,B10101110,
  B11001100,B10001100,B11000100,B01001010,B10101000,B00000000,B00000000,B00000010,B10101000,B10000100,B00100001,B00000000,B00000000,B00000000,B00000000,B10101010,
  B10101000,B10101010,B10000010,B00101010,B10101010,B00000000,B00000000,B00000011,B00101001,B00000010,B00100010,B00100000,B00000000,B00000000,B00000000,B11001010,
  B10101110,B01001010,B11101100,B11001001,B00101000,B00000000,B00000000,B00000010,B00101010,B00001100,B00100011,B10000000,B00000000,B00000000,B00000000,B10001010
};

void plot_loop(float value[], int counter, float regression);
float calc_regression(float x[], float z[], int length);

/**
 * M998: Probe point on bed until bed movement is within specified range
 * By Constantijn Crijnen
 *
 * Parameters:
 *
 *   X   Probe X position (default current X)
 *   Y   Probe Y position (default current Y)
 *   E   Engage the probe for each probe (default 1)
 */
void GcodeSuite::M998() {
  const xy_pos_t pos = { parser.linearval('X', current_position.x + probe.offset_xy.x),
                         parser.linearval('Y', current_position.y + probe.offset_xy.y) };

  if (homing_needed_error()) return;

  ui.capture(); // Disallow interaction with the LCD
  
  // Disable leveling so the planner won't mess with us
  TERN_(HAS_LEVELING, set_bed_leveling_enabled(false));

  remember_feedrate_scaling_off();

  const ProbePtRaise raise_after = parser.boolval('E') ? PROBE_PT_STOW : PROBE_PT_RAISE;

  plot_loop(0, -1, -1);

  constexpr int window = 16;
  constexpr millis_t maxtime = 200 * 1000; // maximum dwell time [ms]
  constexpr float regression_max = 0.05; // [µm/s]

  int i;
  float measured_z_positions_window[window] = {}, // [µm]
        measured_z_positions[(int(maxtime) / 1000) * 2] = {}, // [µm]
        measured_times[window] = {}, // [s]
        measured_times_pre_regression[window] = {},
        mov_mean_z[window-2] = {}; // [µm]
  float regression = 1; // [µm/s]
  int triggercount = 0, counter = 0;

  const millis_t starttime = millis();

  // Find starting z position
  const float start_z = probe.probe_at_point(pos, raise_after, 0);
  SERIAL_ECHOLNPAIR("start_z = ", start_z * 1000);
  
  // Start continuous measurements
  for (i = window - 2; i >= 0; i--) {
    const float measured_z = probe.probe_at_point(pos, raise_after, 0);
    measured_z_positions_window[i] = (measured_z - start_z) * 1000; // [µm]
    measured_times[i] = (millis() - starttime) / 1000; // [s]
    SERIAL_ECHOLNPAIR("measured_z = ", measured_z * 1000);
    SERIAL_ECHOLNPAIR("measured_z_positions_window[i] = ", measured_z_positions_window[i]);

    // Calculate moving mean once there are enough values
    if (counter < 2)
      measured_z_positions[counter] = measured_z_positions_window[i];
    else
      measured_z_positions[counter] = (measured_z_positions_window[i] + measured_z_positions[counter - 1] + measured_z_positions[counter - 2]) / 3;

    measured_times_pre_regression[counter] = measured_times[i];
    //SERIAL_ECHOLNPAIR("measured_times_pre_regression[", counter, "]: ", measured_times_pre_regression[counter]);
    //SERIAL_ECHOLNPAIR("measured_z_positions[", counter, "]: ", measured_z_positions[counter]);
    regression = counter < 1 ? -1.0 : calc_regression(measured_times_pre_regression, measured_z_positions, counter + 1 /*=length*/);

    plot_loop(measured_z_positions, counter, regression);
    counter++; //counter starting at 0
    //SERIAL_ECHOLNPAIR("Z: ", FIXFLOAT(measured_z*1000), "um");
    safe_delay(1000);
  }

  while (triggercount <= 3 && millis() - starttime < maxtime ) {
    // Shifting array elements to the right
    for (int i = window - 1; i > 0; i--) {
      measured_z_positions_window[i] = measured_z_positions_window[i - 1];
      measured_times[i] = measured_times[i - 1];
      //SERIAL_ECHOLNPAIR("measured_z_positions_window[",i,"]: ", measured_z_positions_window[i]);
    }

    // Take measurements and store
    const float measured_z = probe.probe_at_point(pos, raise_after, 0);
    measured_z_positions_window[0] = (measured_z - start_z) * 1000; // [µm]
    measured_z_positions[counter] = measured_z_positions_window[0];

    measured_times[0] = (millis() - starttime) / 1000; //(millis() - sectiontime) / 1000; //[s]
    //sectiontime = millis();

    // clean up data with moving mean of 3
    for (i = 1; i < window - 1; i++)
      mov_mean_z[i - 1] = (measured_z_positions_window[i - 1] + measured_z_positions_window[i] + measured_z_positions_window[i + 1]) / 3;

    measured_z_positions[counter] = mov_mean_z[0];
    regression = calc_regression(measured_times, mov_mean_z, window);
    if (ABS(regression) < regression_max) triggercount++; else triggercount = 0;

    plot_loop(measured_z_positions, counter, regression);
    counter++;

    safe_delay(1000);
  }

  ui.release(); // Re-enable interaction with the LCD

  restore_feedrate_and_scaling();

  // From M402:
  probe.stow();
  probe.move_z_after_probing();
  report_current_position();

  SERIAL_ECHOLNPAIR("Bed has stabilized!");
}

void plot_loop(float value[] = {0}, int counter = -1, float regression = -1) {
  // calculate pixels
  // TODO: Calculation is very inefficient
  if (counter >= 0) {
    int datapixel[counter + 1];
    for (int i = 0; i <= counter; i++) {
      datapixel[i] = 43.0f + ((value[i] / 20.0f / 7.0f) * -1.0f); // (20/7) µm per pixel, zero is at y=43
      LIMIT(datapixel[i], 0, 50);
    }
    SERIAL_ECHOLNPAIR("Z: ", value[counter], "um, Regression: ", regression);
  }

  // picture loop
  u8g.firstPage();
  do {
    u8g.drawBitmapP( 0, 0, 128/8, 64, plot_backdrop);
    for (int i = 0; i <= counter; i++) {
      u8g.drawPixel(17 + i, datapixel[i]); // TODO: datapixel is currently not tied to an exact time value
      u8g.setFont(u8g_font_micro);
      u8g.setFontPosTop();
      u8g.setPrintPos(41, 58);
      u8g.print(regression);
      u8g.setPrintPos(93, 58);
      u8g.print(value[counter]);
    }
  } while (u8g.nextPage());
}

float calc_regression(float x[], float z[], int length) {
  const int samples = length - 2;

  // Calculate Regression
  float sum_x = 0, sum_z = 0;
  for (int i = 0; i < samples; i++) {
    sum_z += z[i];
    sum_x += x[i];
    //SERIAL_ECHOLNPAIR("mov_mean_z[",i,"]: ", mov_mean_z[i]);
  }
  const float mean_z = sum_z / samples,
              mean_x = sum_x / samples;

  float sum_1 = 0, sum_2 = 0;
  for (int i = 0; i < samples; i++) {
    sum_1 += (z[i] - mean_z) * (x[i] - mean_x);
    sum_2 += (x[i] - mean_x) * (x[i] - mean_x);
  }
  return sum_1 / sum_2; // Regression
}

#endif // BED_SWELL_DWELL
